<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IGC Flight Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: white;
      overflow: hidden;
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    .header {
      background: #2a2a3e;
      padding: 20px;
      border-bottom: 1px solid #3a3a4e;
    }
    h1 {
      font-size: 24px;
      margin-bottom: 15px;
    }
    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .btn-primary {
      background: #4a7c59;
      color: white;
    }
    .btn-primary:hover {
      background: #5a8c69;
    }
    .btn-secondary {
      background: #4a5568;
      color: white;
    }
    .btn-secondary:hover {
      background: #5a6578;
    }
    .file-input {
      display: none;
    }
    .file-label {
      background: #3b82f6;
      color: white;
      padding: 10px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .file-label:hover {
      background: #2563eb;
    }
    input[type="range"] {
      flex: 1;
      min-width: 200px;
    }
    .canvas-container {
      flex: 1;
      position: relative;
      background: #1a1a2e;
    }
    canvas {
      width: 100%;
      height: 100%;
      cursor: move;
    }
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #6b7280;
    }
    .empty-state svg {
      margin: 0 auto 20px;
      opacity: 0.5;
    }
    .zoom-info {
      color: white;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>IGC Flight Visualizer</h1>
      <div class="controls">
        <label class="file-label">
          üìÅ Upload IGC File
          <input type="file" class="file-input" id="fileInput" accept=".igc">
        </label>
        
        <button class="btn-primary" id="playBtn" style="display:none;">
          ‚ñ∂Ô∏è Play
        </button>
        
        <select id="speedSelect" style="display:none; padding: 10px; border-radius: 6px; border: none; background: #4a5568; color: white; font-size: 14px; cursor: pointer;">
          <option value="1">1x Speed</option>
          <option value="10">10x Speed</option>
          <option value="50">50x Speed</option>
          <option value="100">100x Speed</option>
        </select>
        
        <button class="btn-secondary" id="resetBtn" style="display:none;">
          üîÑ Reset
        </button>
        
        <button class="btn-secondary" id="zoomInBtn" style="display:none;">
          üîç+ Zoom In
        </button>
        
        <button class="btn-secondary" id="zoomOutBtn" style="display:none;">
          üîç- Zoom Out
        </button>
        
        <span class="zoom-info" id="zoomInfo" style="display:none;"></span>
        
        <input type="range" id="slider" style="display:none;" min="0" max="100" value="0">
      </div>
    </div>
    
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div class="empty-state" id="emptyState">
        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="17 8 12 3 7 8"></polyline>
          <line x1="12" y1="3" x2="12" y2="15"></line>
        </svg>
        <p style="font-size: 20px; margin-bottom: 8px;">Upload an IGC file to visualize your flight</p>
        <p style="font-size: 14px;">Topographic maps ‚Ä¢ Zoom & Pan ‚Ä¢ Flight playback</p>
      </div>
    </div>
  </div>

  <script>
    let igcData = null;
    let isPlaying = false;
    let currentPoint = 0;
    let zoom = 1;
    let pan = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let mapTiles = {};
    let animationInterval = null;
    let playbackSpeed = 1;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const fileInput = document.getElementById('fileInput');
    const playBtn = document.getElementById('playBtn');
    const speedSelect = document.getElementById('speedSelect');
    const resetBtn = document.getElementById('resetBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const slider = document.getElementById('slider');
    const emptyState = document.getElementById('emptyState');
    const zoomInfo = document.getElementById('zoomInfo');

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      if (igcData) drawScene();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function parseIGC(content) {
      const lines = content.split('\n');
      const points = [];
      let minLat = Infinity, maxLat = -Infinity;
      let minLon = Infinity, maxLon = -Infinity;
      let minAlt = Infinity, maxAlt = -Infinity;

      for (const line of lines) {
        if (line.startsWith('B')) {
          const lat = parseFloat(line.substring(7, 9)) + parseFloat(line.substring(9, 14)) / 60000;
          const latSign = line[14] === 'N' ? 1 : -1;
          const lon = parseFloat(line.substring(15, 18)) + parseFloat(line.substring(18, 23)) / 60000;
          const lonSign = line[23] === 'E' ? 1 : -1;
          const alt = parseInt(line.substring(25, 30));

          const point = {
            lat: lat * latSign,
            lon: lon * lonSign,
            alt: alt
          };

          points.push(point);
          minLat = Math.min(minLat, point.lat);
          maxLat = Math.max(maxLat, point.lat);
          minLon = Math.min(minLon, point.lon);
          maxLon = Math.max(maxLon, point.lon);
          minAlt = Math.min(minAlt, point.alt);
          maxAlt = Math.max(maxAlt, point.alt);
        }
      }

      return { points, bounds: { minLat, maxLat, minLon, maxLon, minAlt, maxAlt } };
    }

    function latLonToTile(lat, lon, zoom) {
      const n = Math.pow(2, zoom);
      const x = Math.floor(n * ((lon + 180) / 360));
      const y = Math.floor(n * (1 - (Math.log(Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)) / Math.PI)) / 2);
      return { x, y };
    }

    function tileToLatLon(x, y, z) {
      const n = Math.pow(2, z);
      const lon = (x / n) * 360 - 180;
      const lat = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
      return { lat, lon };
    }

    function loadMapTile(x, y, z) {
      const key = `${z}-${x}-${y}`;
      if (mapTiles[key] !== undefined) return;

      mapTiles[key] = 'loading';

      const img = new Image();
      img.onload = () => {
        mapTiles[key] = img;
        drawScene();
      };
      img.onerror = () => {
        mapTiles[key] = null;
      };
      // USGS Topo - fast loading, reliable, shows contours and terrain
      img.src = `https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/${z}/${y}/${x}`;
    }

    function drawScene() {
      if (!igcData) return;

      const width = canvas.width;
      const height = canvas.height;
      const { points, bounds } = igcData;

      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, width, height);

      const centerLat = (bounds.minLat + bounds.maxLat) / 2;
      const centerLon = (bounds.minLon + bounds.maxLon) / 2;
      
      const latRange = bounds.maxLat - bounds.minLat;
      const lonRange = bounds.maxLon - bounds.minLon;
      
      const margin = 100;
      const pixelsPerDegreeLat = (height - 2 * margin) / latRange;
      const pixelsPerDegreeLon = (width - 2 * margin) / lonRange;
      const baseScale = Math.min(pixelsPerDegreeLat, pixelsPerDegreeLon);
      
      const scale = baseScale * zoom;

      const toCanvasX = (lon) => {
        return width / 2 + (lon - centerLon) * scale + pan.x;
      };
      
      const toCanvasY = (lat) => {
        return height / 2 - (lat - centerLat) * scale + pan.y;
      };

      // Draw USGS topo map tiles - only load tiles that intersect with track
      const tileZoom = Math.min(Math.max(Math.floor(Math.log2(scale * 50)), 4), 14);
      
      // Get bounds of the actual flight track
      const trackMinLat = bounds.minLat;
      const trackMaxLat = bounds.maxLat;
      const trackMinLon = bounds.minLon;
      const trackMaxLon = bounds.maxLon;
      
      // Add small buffer around track
      const bufferDegrees = (Math.max(trackMaxLat - trackMinLat, trackMaxLon - trackMinLon)) * 0.1;
      
      const minTile = latLonToTile(trackMaxLat + bufferDegrees, trackMinLon - bufferDegrees, tileZoom);
      const maxTile = latLonToTile(trackMinLat - bufferDegrees, trackMaxLon + bufferDegrees, tileZoom);
      
      for (let tileX = minTile.x; tileX <= maxTile.x; tileX++) {
        for (let tileY = minTile.y; tileY <= maxTile.y; tileY++) {
          const maxTileCount = Math.pow(2, tileZoom);
          if (tileX < 0 || tileY < 0 || tileX >= maxTileCount || tileY >= maxTileCount) continue;
          
          const key = `${tileZoom}-${tileX}-${tileY}`;
          const tile = mapTiles[key];
          
          const tilePos = tileToLatLon(tileX, tileY, tileZoom);
          const nextTilePos = tileToLatLon(tileX + 1, tileY + 1, tileZoom);
          
          const tileCanvasX = toCanvasX(tilePos.lon);
          const tileCanvasY = toCanvasY(tilePos.lat);
          const tileCanvasX2 = toCanvasX(nextTilePos.lon);
          const tileCanvasY2 = toCanvasY(nextTilePos.lat);
          
          const tileWidth = Math.abs(tileCanvasX2 - tileCanvasX);
          const tileHeight = Math.abs(tileCanvasY2 - tileCanvasY);
          
          if (tile && tile !== 'loading' && tile !== null) {
            ctx.globalAlpha = 1.0;
            ctx.drawImage(tile, tileCanvasX, tileCanvasY, tileWidth, tileHeight);
            ctx.globalAlpha = 1;
          } else if (!tile) {
            // Draw dark placeholder while loading satellite imagery
            ctx.fillStyle = 'rgba(40, 50, 40, 0.5)';
            ctx.fillRect(tileCanvasX, tileCanvasY, tileWidth, tileHeight);
            loadMapTile(tileX, tileY, tileZoom);
          }
        }
      }

      const altRange = bounds.maxAlt - bounds.minAlt;

      // Draw complete flight path
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.4)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      points.forEach((point, i) => {
        const x = toCanvasX(point.lon);
        const y = toCanvasY(point.lat);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Draw colored path up to current point
      const displayPoints = points.slice(0, currentPoint + 1);
      if (displayPoints.length > 1) {
        displayPoints.forEach((point, i) => {
          if (i === 0) return;
          
          const prev = displayPoints[i - 1];
          const x1 = toCanvasX(prev.lon);
          const y1 = toCanvasY(prev.lat);
          const x2 = toCanvasX(point.lon);
          const y2 = toCanvasY(point.lat);
          
          const altRatio = altRange > 0 ? (point.alt - bounds.minAlt) / altRange : 0;
          const hue = 240 - (altRatio * 180);
          ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
          ctx.lineWidth = 4;
          
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        });
      }

      // Draw current position
      if (currentPoint < points.length) {
        const current = points[currentPoint];
        const x = toCanvasX(current.lon);
        const y = toCanvasY(current.lat);
        
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(x, y, 12, 0, Math.PI * 2);
        ctx.stroke();

        // Info box
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(5, 5, 180, 75);
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText(`Alt: ${current.alt}m`, 10, 25);
        ctx.fillText(`Lat: ${current.lat.toFixed(5)}`, 10, 45);
        ctx.fillText(`Lon: ${current.lon.toFixed(5)}`, 10, 65);
      }

      // Altitude legend
      const legendX = width - 70;
      const legendY = 50;
      const legendHeight = 200;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(legendX - 5, legendY - 5, 85, legendHeight + 50);
      
      for (let i = 0; i <= legendHeight; i++) {
        const ratio = i / legendHeight;
        const hue = 240 - (ratio * 180);
        ctx.strokeStyle = `hsl(${hue}, 100%, 60%)`;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY + legendHeight - i);
        ctx.lineTo(legendX + 20, legendY + legendHeight - i);
        ctx.stroke();
      }
      
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText(`${Math.round(bounds.maxAlt)}m`, legendX + 25, legendY + 5);
      ctx.fillText(`${Math.round(bounds.minAlt)}m`, legendX + 25, legendY + legendHeight + 5);
      ctx.fillText('Altitude', legendX - 5, legendY + legendHeight + 30);
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          igcData = parseIGC(event.target.result);
          currentPoint = 0;
          zoom = 1;
          pan = { x: 0, y: 0 };
          slider.max = igcData.points.length - 1;
          slider.value = 0;
          
          emptyState.style.display = 'none';
          playBtn.style.display = 'flex';
          speedSelect.style.display = 'block';
          resetBtn.style.display = 'flex';
          zoomInBtn.style.display = 'flex';
          zoomOutBtn.style.display = 'flex';
          slider.style.display = 'block';
          zoomInfo.style.display = 'block';
          zoomInfo.textContent = `Zoom: ${zoom.toFixed(1)}x`;
          
          drawScene();
        };
        reader.readAsText(file);
      }
    });

    playBtn.addEventListener('click', () => {
      if (isPlaying) {
        isPlaying = false;
        playBtn.textContent = '‚ñ∂Ô∏è Play';
        clearInterval(animationInterval);
      } else {
        isPlaying = true;
        playBtn.textContent = '‚è∏Ô∏è Pause';
        animationInterval = setInterval(() => {
          if (currentPoint >= igcData.points.length - 1) {
            isPlaying = false;
            playBtn.textContent = '‚ñ∂Ô∏è Play';
            clearInterval(animationInterval);
            return;
          }
          currentPoint += playbackSpeed;
          if (currentPoint >= igcData.points.length) {
            currentPoint = igcData.points.length - 1;
          }
          slider.value = currentPoint;
          drawScene();
        }, 50);
      }
    });

    speedSelect.addEventListener('change', (e) => {
      playbackSpeed = parseInt(e.target.value);
      // If currently playing, restart with new speed
      if (isPlaying) {
        clearInterval(animationInterval);
        animationInterval = setInterval(() => {
          if (currentPoint >= igcData.points.length - 1) {
            isPlaying = false;
            playBtn.textContent = '‚ñ∂Ô∏è Play';
            clearInterval(animationInterval);
            return;
          }
          currentPoint += playbackSpeed;
          if (currentPoint >= igcData.points.length) {
            currentPoint = igcData.points.length - 1;
          }
          slider.value = currentPoint;
          drawScene();
        }, 50);
      }
    });

    resetBtn.addEventListener('click', () => {
      currentPoint = 0;
      zoom = 1;
      pan = { x: 0, y: 0 };
      slider.value = 0;
      isPlaying = false;
      playBtn.textContent = '‚ñ∂Ô∏è Play';
      clearInterval(animationInterval);
      zoomInfo.textContent = `Zoom: ${zoom.toFixed(1)}x`;
      drawScene();
    });

    zoomInBtn.addEventListener('click', () => {
      zoom = Math.min(zoom * 1.3, 20);
      zoomInfo.textContent = `Zoom: ${zoom.toFixed(1)}x`;
      drawScene();
    });

    zoomOutBtn.addEventListener('click', () => {
      zoom = Math.max(zoom / 1.3, 0.5);
      zoomInfo.textContent = `Zoom: ${zoom.toFixed(1)}x`;
      drawScene();
    });

    slider.addEventListener('input', (e) => {
      currentPoint = parseInt(e.target.value);
      drawScene();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoom = Math.min(Math.max(zoom * delta, 0.5), 20);
      zoomInfo.textContent = `Zoom: ${zoom.toFixed(1)}x`;
      drawScene();
    });

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        pan = {
          x: e.clientX - dragStart.x,
          y: e.clientY - dragStart.y
        };
        drawScene();
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });
  </script>
</body>
</html>
